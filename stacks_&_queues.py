# -*- coding: utf-8 -*-
"""Stacks & Queues.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1giSG6ohOxbQ5Krf3tVF0iLVlNUqfawap
"""

stk = []

stk.append(1)
stk.append(3)
stk.append(5)
stk.append(7)

stk

stk.pop()

stk

# check it the stack contain elements & if yes it will return true
q = [1,2]
if q:
  print(True)

#Queues
from collections import deque
b = deque()
b



b.append(1)
b.append(3)
b.append(5)
b.append(7)

b

b.popleft()

b

b[0]

b[-1]

def max_stack_depth(expression):
    # Initialize an empty stack and variable to track maximum depth
    stack = []
    max_depth = 0

    # Iterate over each character in the expression
    for char in expression:
        if char == '(':
            stack.append(char)  # Push opening parenthesis onto stack
            max_depth = max(max_depth, len(stack))  # Update max depth
        elif char == ')' and stack:
            stack.pop()  # Pop closing parenthesis from stack

    return max_depth

# Test expression
expression = ")()())"

max_stack_depth(expression)

def binary_search(arr, target):
    left = 0
    right = len(arr) - 1
    iterations = 0



    while left <= right:
        iterations += 1
        mid = (left + right) // 2
        print(arr[mid])
        if arr[mid] == target:
            return iterations
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1  # If the target is not found

# Test the binary search function
arr = [27, 63, 111, 151, 253, 290, 318, 384, 402, 502, 661, 704, 705, 746, 766, 806, 812, 846, 875, 945, 960, 998]
iterations = binary_search(arr, 705)

iterations

